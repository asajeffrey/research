% \documentclass[acmsmall,review,screen,anonymous]{acmart}
\documentclass[acmsmall,review,screen]{acmart}

\acmYear{2025}
\copyrightyear{2025}
\acmJournal{PACMPL}
\acmVolume{9}
\acmNumber{POPL}
\acmArticle{??}
\acmMonth{1}

\expandafter\def\csname @copyrightpermission\endcsname{\raisebox{-1ex}{\includegraphics[height=3.5ex]{cc-by}} This work is licensed under a Creative Commons Attribution 4.0 International License.}
\expandafter\def\csname @copyrightowner\endcsname{\anon{Roblox}.}

\newcommand{\infer}[2]{\frac{\displaystyle\begin{array}{@{}l@{}}#1\end{array}}{\displaystyle#2}}
\newcommand{\ANY}{\mathtt{any}}
\newcommand{\UNKNOWN}{\mathtt{unknown}}
\newcommand{\ERROR}{\mathtt{error}}
\newcommand{\NUMBER}{\mathtt{number}}
\newcommand{\STRING}{\mathtt{string}}
\newcommand{\WARN}{\mathsf{Warn}}
\newcommand{\UNION}{\mathbin{\mathtt{\char`\|}}}
\newcommand{\fun}{\mathbin{\rightarrow}}
\newcommand{\compat}{\sim}

\begin{document}

\title{Gradual Types as Error Suppression}
\subtitle{A Constructive View of Type Warnings}

\author{Lily Brown}
\author{Andy Friesen}
\author{Alan Jeffrey}
\affiliation{
  \institution{Roblox}
  \city{San Mateo}
  \state{CA}
  \country{USA}
}

\begin{abstract}
  This paper presents the view of gradual typing adopted by the
  \anon{Luau} programming language. Prior work on gradual typing has
  been based on \emph{type compatibility}, that is a relation on types
  $T \compat U$ given by contextually closing $T \compat \ANY \compat
  U$.  Type systems based on type compatibility use $\compat$ rather
  than type equivalence (or a similar presentation for languages with
  subtyping). We take a different tack, which is to view type warnings
  \emph{constructively} as a proof object $\WARN(\Gamma \vdash M : T)$
  saying that the type derivation $\Gamma \vdash M : T$ should
  generate a warning. Viewing type warnings constructively allows us
  to talk about \emph{error suppression}, for example the $\ANY$ type
  is error suppressing, and so this type system is gradual in the
  sense that developers can explicitly annotate terms with the $\ANY$
  type to switch off type warnings. This system has the usual ``well-typed
  programs don't go wrong'' result for program which do not have
  explicit type annotations with error suppressing types, except this
  property can now be stated as the presence of $\WARN(\Gamma \vdash M
  : T)$ rather than the absence of a run-time error. This system has
  been deployed as part of the \anon{Luau} programming language, used
  by \anon{millions of users of Roblox Studio}.
\end{abstract}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011039.10011311</concept_id>
<concept_desc>Software and its engineering~Semantics</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}
\ccsdesc[500]{Software and its engineering~Semantics}

\maketitle

\section{Introduction}

\subsection{Gradual Typing}

The aim of \emph{gradual
typing}~\cite{ST06:GradualTyping,ST07:GradualTyping} is to allow a
code base to migrate from being untyped to being typed.  This is
achieved by introducing a type $\ANY$ (also called $?$ or $*$) which
is used as the type of a expression which is not subject to type
checking. For example, in \anon{Luau}, a variable can be declared as
having type $\ANY$, which is not subject to type checking:
\begin{verbatim}
  local x : any = "hi"
  print(math.abs(x))
\end{verbatim}
This program generates a run-time error, but because \verb|x| is
declared has having type $\ANY$, no type error is generated.
Similarly, any expression can be cast to having type $\ANY$, which is
not subject to type checking:
\begin{verbatim}
  print(math.abs("hi" :: any))
\end{verbatim}
Again, this program generates a run-time error, but because \verb|"hi"| is
cast to  having type $\ANY$, no type error is generated.

Prior work on gradual typing has been based on \emph{type
compatibility}, that is a relation on types $T \compat U$ given by
contextually closing $T \compat \ANY \compat U$.  Type systems based
on type compatibility use $\compat$ rather than type equivalence (or a
similar presentation for languages with subtyping).

For example, the type rules for function application
in~\cite{ST06:GradualTyping} are:
\[
    \infer{
      \Gamma \vdash M : \ANY \\
      \Gamma \vdash N : U
    }{
      \Gamma \vdash M(N) : \ANY
    }
    (\textsc{GApp}1)
\qquad
    \infer{
      \Gamma \vdash M : (S \fun T) \\
      \Gamma \vdash N : U \\
      S \compat U
    }{
      \Gamma \vdash M(N) : T
    }
    (\textsc{GApp}2)
\]
which requires that the argument type is \emph{compatible} with
(rather than equal to) to the function source type.
For example:
\[
    \infer{
      \Gamma \vdash \mathtt{math.abs} : (\NUMBER \fun \NUMBER) \\
      \Gamma \vdash x : \ANY \\
      \NUMBER \compat \ANY
    }{
      \Gamma \vdash \mathtt{math.abs}(x) : \NUMBER
    }
\]
The problem we discovered in implementing gradual typing on top of type
compatibility is that it is a source of subtle bug, because the type
system is very sensitive as to when type equality is used rather than
type compatibility. For example comparing two type rules:
\[
    \infer{
      \Gamma \vdash M : F \\
      \Gamma \vdash N : U \\
      F = (S \fun T) \\
      S \compat U
    }{
      \Gamma \vdash M(N) : T
    }
    (\textsc{GApp}2')
 \qquad
    \infer{
      \Gamma \vdash M : F \\
      \Gamma \vdash N : U \\
      F \compat (S \fun T) \\
      S \compat U
    }{
      \Gamma \vdash M(N) : T
    }
    (\textsc{GApp}2'')
\]
These rules only differ in whether they use type compatibility
rater than equality, but they have very different semantics. Rule
$\textsc{GApp}2'$ is the same as $\textsc{GApp}2'$ (and so is sound)
but using $\textsc{GApp}2''$ we can derive:
\[
    \infer{
      \Gamma \vdash \mathtt{math.abs} : (\NUMBER \fun \NUMBER) \\
      \Gamma \vdash x : \STRING \\
      (\NUMBER \fun \NUMBER) \compat (\ANY \fun \NUMBER) \\
      \ANY \compat \STRING \\
    }{
      \Gamma \vdash \mathtt{math.abs}(x) : \NUMBER
    }
\]
which is unsound. Problems like this come down eventually to the fact
that $\compat$ is not transitive, and in the presence of other
features such as unification and subtyping gave rise to subtle bugs
(for example code that assumed that unification solved for type
equality rather than compatibility).

\subsection{Error Suppressing Types}

There as been a long history of improving type errors reported to
users, going back to the
1980s~\cite{Wan86:FindingSource,JW86:MaximumFlow}.
One source of pain in type error reporting is \emph{cascading}
type errors, for example:
\begin{verbatim}
  local x = "hi"
  local y = math.abs(x)
  local z = string.lower(y)
\end{verbatim}
In this case \verb|math.abs(x)| should generate a type error, since
the type $\STRING$ is inferred for \verb|x|, and the type of
\verb|math.abs| is $\NUMBER \fun \NUMBER$.  It is not obvious whether
a type error should be generated for \verb|string.lower(y)|. If the
type $\NUMBER$ is inferred for \verb|y|, then an error should be
reported, since the type of \verb|string.lower| is $\STRING \fun \STRING$.
But this will not be the best user experience, since this will
give a common experience of multiple cascading type errors, of which only
the first error is genuine.

One heuristic to eliminate cascading errors is to mark the type of any
expression which causes a type error to be emitted as \emph{error
suppressing}. Error suppressing types are then used to percolate the
information that a type error has already been generated, and so avoid
cascading type errors.

For example, in \anon{Luau}, a type $\ERROR$ is introduced, and any
type $T$ which is a supertype of $\ERROR$ is considered to be error
suppressing. For instance, the types inferred for the above program
are:
\begin{verbatim}
  local x : string = "hi"
  local y : number | error = math.abs(x)
  local z : string | error = string.lower(y)
\end{verbatim}
Since $\NUMBER \UNION \ERROR$ is an error suppressing type,
\verb|string.lower(y)| will not report a type error.

The existence of $\ERROR$ explains why \anon{Luau}, in common with
TypeScript~\cite{TypeScript}, has both an error suppressing type $\ANY$ and a
non-error suppressing type $\UNKNOWN$. $\ANY$ is the top type, and
$\UNKNOWN$ is the top non-error-suppressing type. We consider
$\ANY$ to be equivalent to $\UNKNOWN \UNION \ERROR$.

Error suppressing types as a technique for minimizing cascading type
errors appears to folklore, for example it is implemented in Typed
Racket~\cite{TH08:ErrorHandling}, but does not appear to have been
academically published.

\subsection{Gradual Typing via Error Suppressing Types}

\subsection{Constructive Type Errors}

\subsection{Contributions}

\section{Further work}

TODO

\appendix

\section{Pragmatic Semantic Subtyping}

TODO

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
