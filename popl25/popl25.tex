% \documentclass[acmsmall,review,screen,anonymous]{acmart}
\documentclass[acmsmall,review,screen]{acmart}

\acmYear{2025}
\copyrightyear{2025}
\acmJournal{PACMPL}
\acmVolume{9}
\acmNumber{POPL}
\acmArticle{??}
\acmMonth{1}

\expandafter\def\csname @copyrightpermission\endcsname{\raisebox{-1ex}{\includegraphics[height=3.5ex]{cc-by}} This work is licensed under a Creative Commons Attribution 4.0 International License.}
\expandafter\def\csname @copyrightowner\endcsname{\anon{Roblox}.}

\newcommand{\infer}[2]{\frac{\displaystyle\begin{array}{@{}l@{}}#1\end{array}}{\displaystyle#2}}
\newcommand{\ANY}{\mathtt{any}}
\newcommand{\UNKNOWN}{\mathtt{unknown}}
\newcommand{\ERROR}{\mathtt{error}}
\newcommand{\NUMBER}{\mathtt{number}}
\newcommand{\STRING}{\mathtt{string}}
\newcommand{\WARN}{\mathsf{Warn}}
\newcommand{\RUNTIMEERR}{\mathsf{RunTimeErr}}
\newcommand{\APPLY}{\mathsf{apply}}
\newcommand{\APP}{\mathsf{app}}
\newcommand{\SRC}{\mathsf{src}}
\newcommand{\TYPEOF}{\mathsf{typeof}}
\newcommand{\UNION}{\mathbin{\mathtt{\char`\|}}}
\newcommand{\fun}{\mathbin{\rightarrow}}
\newcommand{\compat}{\sim}
\newcommand{\st}{\mathbin.}

\begin{document}

\title{Gradual Types as Error Suppression}
\subtitle{A Constructive View of Type Warnings}

\author{Lily Brown}
\author{Andy Friesen}
\author{Alan Jeffrey}
\affiliation{
  \institution{Roblox}
  \city{San Mateo}
  \state{CA}
  \country{USA}
}

\begin{abstract}
  This paper presents the view of gradual typing adopted by the
  \anon{Luau} programming language. Prior work on gradual typing has
  been based on \emph{type compatibility}, that is a relation on types
  $T \compat U$ given by contextually closing $T \compat \ANY \compat
  U$.  Type systems based on type compatibility use $\compat$ rather
  than type equivalence (or a similar presentation for languages with
  subtyping). We take a different tack, which is to view type warnings
  \emph{constructively} as a proof object $\WARN(\Gamma \vdash M : T)$
  saying that the type derivation $\Gamma \vdash M : T$ should
  generate a warning. Viewing type warnings constructively allows us
  to talk about \emph{error suppression}, for example the $\ANY$ type
  is error suppressing, and so this type system is gradual in the
  sense that developers can explicitly annotate terms with the $\ANY$
  type to switch off type warnings. This system has the usual ``well-typed
  programs don't go wrong'' result for program which do not have
  explicit type annotations with error suppressing types, except this
  property can now be stated as the presence of $\WARN(\Gamma \vdash M
  : T)$ rather than the absence of a run-time error. This system has
  been deployed as part of the \anon{Luau} programming language, used
  by \anon{millions of users of Roblox Studio}.
\end{abstract}

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011039.10011311</concept_id>
<concept_desc>Software and its engineering~Semantics</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}
\ccsdesc[500]{Software and its engineering~Semantics}

\maketitle

\section{Introduction}

\subsection{Gradual Typing}

The aim of \emph{gradual
typing}~\cite{ST06:GradualTyping,ST07:GradualTyping} is to allow a
code base to migrate from being untyped to being typed.  This is
achieved by introducing a type $\ANY$ (also called $?$ or $*$) which
is used as the type of a expression which is not subject to type
checking. For example, in \anon{Luau}, a variable can be declared as
having type $\ANY$, which is not subject to type checking:
\begin{verbatim}
  local x : any = "hi"
  print(math.abs(x))
\end{verbatim}
This program generates a run-time error, but because \verb|x| is
declared has having type $\ANY$, no type error is generated.
Similarly, any expression can be cast to having type $\ANY$, which is
not subject to type checking:
\begin{verbatim}
  print(math.abs("hi" :: any))
\end{verbatim}
Again, this program generates a run-time error, but because \verb|"hi"| is
cast to  having type $\ANY$, no type error is generated.

Prior work on gradual typing has been based on \emph{type
compatibility}, that is a relation on types $T \compat U$ given by
contextually closing $T \compat \ANY \compat U$.  Type systems based
on type compatibility use $\compat$ rather than type equivalence (or a
similar presentation for languages with subtyping).

For example, the type rules for function application
in~\cite{ST06:GradualTyping} are:
\[
    \infer{
      \Gamma \vdash M : \ANY \\
      \Gamma \vdash N : U
    }{
      \Gamma \vdash M(N) : \ANY
    }
    (\textsc{GApp}1)
\qquad
    \infer{
      \Gamma \vdash M : (S \fun T) \\
      \Gamma \vdash N : U \\
      S \compat U
    }{
      \Gamma \vdash M(N) : T
    }
    (\textsc{GApp}2)
\]
which requires that the argument type is \emph{compatible} with
(rather than equal to) to the function source type.
For example:
\[
    \infer{
      \Gamma \vdash \mathtt{math.abs} : (\NUMBER \fun \NUMBER) \\
      \Gamma \vdash x : \ANY \\
      \NUMBER \compat \ANY
    }{
      \Gamma \vdash \mathtt{math.abs}(x) : \NUMBER
    }
\]
The problem we discovered in implementing gradual typing on top of type
compatibility is that it is a source of subtle bug, because the type
system is very sensitive as to when type equality is used rather than
type compatibility. For example comparing two type rules:
\[
    \infer{
      \Gamma \vdash M : F \\
      \Gamma \vdash N : U \\
      F = (S \fun T) \\
      S \compat U
    }{
      \Gamma \vdash M(N) : T
    }
    (\textsc{GApp}2')
 \qquad
    \infer{
      \Gamma \vdash M : F \\
      \Gamma \vdash N : U \\
      F \compat (S \fun T) \\
      S \compat U
    }{
      \Gamma \vdash M(N) : T
    }
    (\textsc{GApp}2'')
\]
These rules only differ in whether they use type compatibility
rater than equality, but they have very different semantics. Rule
$\textsc{GApp}2'$ is the same as $\textsc{GApp}2'$ (and so is sound)
but using $\textsc{GApp}2''$ we can derive:
\[
    \infer{
      \Gamma \vdash \mathtt{math.abs} : (\NUMBER \fun \NUMBER) \\
      \Gamma \vdash x : \STRING \\
      (\NUMBER \fun \NUMBER) \compat (\ANY \fun \NUMBER) \\
      \ANY \compat \STRING \\
    }{
      \Gamma \vdash \mathtt{math.abs}(x) : \NUMBER
    }
\]
which is unsound. Problems like this come down eventually to the fact
that $\compat$ is not transitive, and in the presence of other
features such as unification and subtyping gave rise to subtle bugs
(for example code that assumed that unification solved for type
equality rather than compatibility).

\subsection{Error Suppressing Types}

There as been a long history of improving type errors reported to
users, going back to the
1980s~\cite{Wan86:FindingSource,JW86:MaximumFlow}.
One source of pain in type error reporting is \emph{cascading}
type errors, for example:
\begin{verbatim}
  local x = "hi"
  local y = math.abs(x)
  local z = string.lower(y)
\end{verbatim}
In this case \verb|math.abs(x)| should generate a type error, since
the type $\STRING$ is inferred for \verb|x|, and the type of
\verb|math.abs| is $\NUMBER \fun \NUMBER$.  It is not obvious whether
a type error should be generated for \verb|string.lower(y)|. If the
type $\NUMBER$ is inferred for \verb|y|, then an error should be
reported, since the type of \verb|string.lower| is $\STRING \fun \STRING$.
But this will not be the best user experience, since this will
give a common experience of multiple cascading type errors, of which only
the first error is genuine.

One heuristic to eliminate cascading errors is to mark the type of any
expression which causes a type error to be emitted as \emph{error
suppressing}. Error suppressing types are then used to percolate the
information that a type error has already been generated, and so avoid
cascading type errors.

For example, in \anon{Luau}, a type $\ERROR$ is introduced, and any
type $T$ which is a supertype of $\ERROR$ is considered to be error
suppressing. For instance, the types inferred for the above program
are:
\begin{verbatim}
  local x : string = "hi"
  local y : number | error = math.abs(x)
  local z : string | error = string.lower(y)
\end{verbatim}
Since $\NUMBER \UNION \ERROR$ is an error suppressing type,
\verb|string.lower(y)| will not report a type error.

Error suppressing types as a technique for minimizing cascading type
errors appears to folklore, for example it is implemented in Typed
Racket~\cite{TH08:ErrorHandling}, but does not appear to have been
academically published.

\subsection{Gradual Typing via Error Suppressing Types}

At this point a reader might guess where this paper is going.  Gradual
types are well established research area which allows programmers
to type expressions with type $\ANY$ to suppress type errors.  Error
suppressing types are well established folklore which
allows type inference to type expressions with error suppressing types
to suppress cascading type errors.

The connection between these two areas is pretty obvious, but has not
been made before. If $\ANY$ is an error suppressing type, then
gradual typing is very similar to error suppression, but does
not require the non-transitive type compatibility relation.

In \anon{Luau}, the use of error suppressing types explains why
\anon{Luau}, in common with TypeScript~\cite{TypeScript}, has both an
error suppressing type $\ANY$ and a non-error suppressing type
$\UNKNOWN$. $\ANY$ is the top type, and $\UNKNOWN$ is the top
non-error-suppressing type. We consider $\ANY$ to be equivalent to
$\UNKNOWN \UNION \ERROR$.

\subsection{Constructive Type Errors}

Error suppressing types is a folklore implementation technique
for suppressing cascading type errors. In this paper we present
a formalization as a constructive model of type errors. We do this by
separating out type derivations fro type errors.

For example, one traditional way to present the type rule for function
application is:
\[
  \infer{
    \Gamma \vdash M : T \\
    \Gamma \vdash N : U \\
    U <: \SRC(T)
  }{
    \Gamma \vdash M(N) : \APPLY(T,U)
  }
\]
using functions to calculate the domain of a function $\SRC(T)$, for example
following~\cite[\S5.2]{Ken21:DownDirty}:
\[
  \SRC(S \fun T) = S
\quad
  \SRC(S \cap T) = \SRC(S) \cup \SRC(T)
\quad
  \cdots
\]
and to calculate the result type of applying a function $\APPLY(T,U)$,
for example following~\cite[\S5.3]{Ken21:DownDirty}:
\[ 
  \APPLY(S \fun T, U) =
  \left\{\begin{array}{@{}ll}
    T & \text{if } U <: T \\
    \ANY & \text{otherwise}
  \end{array}\right.
\quad
  \APPLY(S \cap T, U) = \APPLY(S, U) \cap \APPLY(T, U)
\quad
  \cdots
\]
(The details of these function are spelled out in Appendix~\ref{app:semsub}.)

This formulation is fine if is one is only interested in well typed programs,
and in not in the behavior of badly typed programs. For example,
the classic ``well typed programs don't go wrong'' can be stated as:
\[
  (M \rightarrow^* M') \fun
  (\RUNTIMEERR(M')) \fun
  \neg(\emptyset \vdash M : T)
\]
(for an appropriate definition of $\RUNTIMEERR(M')$). Now, this does not have
a constructive model of type warnings, since we are only considering
badly typed programs as ones where $\neg(\emptyset \vdash M : T)$.

In this paper, we separate type derivations from their type errors.
This is done by explicitly tracking the derivation tree for typing,
for example:
\[
  \infer{
    D_1 : (\Gamma \vdash M : T) \\
    D_2 : (\Gamma \vdash N : U)
  }{
    \APP(D_1, D_2) : (\Gamma \vdash M(N) : \APPLY(T,U))
  }
\]
which allows us to define which type derivations generate warnings,
for example there are three ways a warning can be generated from a
function application $M(N)$, bubbling up a warning from $M$ or $N$, or
by a failure of subtyping:
\[
  \infer{
    \WARN(D_1)
  }{
    \WARN(\APP(D_1, D_2))
  }
\quad
  \infer{
    \WARN(D_2)
  }{
    \WARN(\APP(D_1, D_2))
  }
\quad
  \infer{
    U \not<: \SRC(T)
  }{
    \WARN(\APP(D_1, D_2))
  }
\]
Now, there are two important results about this presentation of
constructive type errors. The first is \emph{infallible typing},
that every program can be type checked in every context:
\[
  \forall \Gamma, M \st
  \exists T \st
  (\Gamma \vdash M : T)
\]
(We write $\TYPEOF(\Gamma, M)$ for this derivation tree.)
The second is that we can state ``well typed programs don't go wrong''
constructively:
\[
  (M \rightarrow^* M') \fun
  (\RUNTIMEERR(M')) \fun
  \WARN(\TYPEOF(\emptyset, M))
\]
Since this is phased constructively,
Curry Howard means we can think of this statement in two ways:
\begin{itemize}
  \item as a proof that ``well typed programs don't go wrong''
  \item as a time-travel debugger,
    that for any execution $(M \rightarrow^* M')$
    where $M'$ has a run-time error,
    it can be run back in time to find a root cause type error for $M'$.
\end{itemize}
  
\subsection{Contributions}

\section{Further work}

TODO

\appendix

\section{Pragmatic Semantic Subtyping}
\label{app:semsub}

TODO

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
